{
  "language": "Solidity",
  "sources": {
    "contracts/base/AbstractDividends.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\nimport \"../libraries/LowGasSafeMath.sol\";\nimport \"../libraries/SafeCast.sol\";\nimport \"../interfaces/IAbstractDividends.sol\";\n\n/**\n * @dev Many functions in this contract were taken from this repository:\n * https://github.com/atpar/funds-distribution-token/blob/master/contracts/FundsDistributionToken.sol\n * which is an example implementation of ERC 2222, the draft for which can be found at\n * https://github.com/atpar/funds-distribution-token/blob/master/EIP-DRAFT.md\n *\n * This contract has been substantially modified from the original and does not comply with ERC 2222.\n * Many functions were renamed as \"dividends\" rather than \"funds\" and the core functionality was separated\n * into this abstract contract which can be inherited by anything tracking ownership of dividend shares.\n */\nabstract contract AbstractDividends is IAbstractDividends {\n  using LowGasSafeMath for uint256;\n  using SafeCast for uint128;\n  using SafeCast for uint256;\n  using SafeCast for int256;\n  using SignedSafeMath for int256;\n\n/* ========  Constants  ======== */\n  uint128 internal constant POINTS_MULTIPLIER = type(uint128).max;\n\n/* ========  Internal Function References  ======== */\n  function(address) view returns (uint256) private immutable getSharesOf;\n  function() view returns (uint256) private immutable getTotalShares;\n\n/* ========  Storage  ======== */\n  uint256 public pointsPerShare;\n  mapping(address => int256) internal pointsCorrection;\n  mapping(address => uint256) private withdrawnDividends;\n\n  constructor(\n    function(address) view returns (uint256) getSharesOf_,\n    function() view returns (uint256) getTotalShares_\n  ) {\n    getSharesOf = getSharesOf_;\n    getTotalShares = getTotalShares_;\n  }\n\n/* ========  Public View Functions  ======== */\n  /**\n   * @dev Returns the total amount of dividends a given address is able to withdraw.\n   * @param account Address of a dividend recipient\n   * @return A uint256 representing the dividends `account` can withdraw\n   */\n  function withdrawableDividendsOf(address account) public view override returns (uint256) {\n    return cumulativeDividendsOf(account).sub(withdrawnDividends[account]);\n  }\n\n  /**\n   * @notice View the amount of dividends that an address has withdrawn.\n   * @param account The address of a token holder.\n   * @return The amount of dividends that `account` has withdrawn.\n   */\n  function withdrawnDividendsOf(address account) public view override returns (uint256) {\n    return withdrawnDividends[account];\n  }\n\n  /**\n   * @notice View the amount of dividends that an address has earned in total.\n   * @dev accumulativeFundsOf(account) = withdrawableDividendsOf(account) + withdrawnDividendsOf(account)\n   * = (pointsPerShare * balanceOf(account) + pointsCorrection[account]) / POINTS_MULTIPLIER\n   * @param account The address of a token holder.\n   * @return The amount of dividends that `account` has earned in total.\n   */\n  function cumulativeDividendsOf(address account) public view override returns (uint256) {\n    return pointsPerShare\n      .mul(getSharesOf(account))\n      .toInt256()\n      .add(pointsCorrection[account])\n      .toUint256() / POINTS_MULTIPLIER;\n  }\n\n/* ========  Dividend Utility Functions  ======== */\n\n  /** \n   * @notice Distributes dividends to token holders.\n   * @dev It reverts if the total supply is 0.\n   * It emits the `FundsDistributed` event if the amount to distribute is greater than 0.\n   * About undistributed dividends:\n   *   In each distribution, there is a small amount which does not get distributed,\n   *   which is `(amount * POINTS_MULTIPLIER) % totalShares()`.\n   *   With a well-chosen `POINTS_MULTIPLIER`, the amount of funds that are not getting\n   *   distributed in a distribution can be less than 1 (base unit).\n   */\n  function _distributeDividends(uint256 amount) internal {\n    uint256 shares = getTotalShares();\n    require(shares > 0, \"SHARES\");\n\n    if (amount > 0) {\n      pointsPerShare = pointsPerShare.add(\n        amount.mul(POINTS_MULTIPLIER) / shares\n      );\n      emit DividendsDistributed(msg.sender, amount);\n    }\n  }\n\n  /**\n   * @notice Prepares collection of owed dividends\n   * @dev It emits a `DividendsWithdrawn` event if the amount of withdrawn dividends is\n   * greater than 0.\n   */\n  function _prepareCollect(address account) internal returns (uint256) {\n    uint256 _withdrawableDividend = withdrawableDividendsOf(account);\n    if (_withdrawableDividend > 0) {\n      withdrawnDividends[account] = withdrawnDividends[account].add(_withdrawableDividend);\n      emit DividendsWithdrawn(account, _withdrawableDividend);\n    }\n    return _withdrawableDividend;\n  }\n\n  function _correctPointsForTransfer(address from, address to, uint256 shares) internal {\n    int256 _magCorrection = pointsPerShare.mul(shares).toInt256();\n    pointsCorrection[from] = pointsCorrection[from].add(_magCorrection);\n    pointsCorrection[to] = pointsCorrection[to].sub(_magCorrection);\n  }\n\n  /**\n   * @dev Increases or decreases the points correction for `account` by\n   * `shares*pointsPerShare`.\n   */\n  function _correctPoints(address account, int256 shares) internal {\n    pointsCorrection[account] = pointsCorrection[account]\n      .add(shares.mul(int256(pointsPerShare)));\n  }\n}"
    },
    "@openzeppelin/contracts/math/SignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @title SignedSafeMath\n * @dev Signed math operations with safety checks that revert on error.\n */\nlibrary SignedSafeMath {\n    int256 constant private _INT256_MIN = -2**255;\n\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n}\n"
    },
    "contracts/libraries/LowGasSafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.0;\n\n/************************************************************************************************\nOriginally from https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/libraries/LowGasSafeMath.sol\n\nThis source code has been modified from the original, which was copied from the github repository\nat commit hash b83fcf497e895ae59b97c9d04e997023f69b5e97.\n\nSubject to the GPL-2.0-or-later license\n*************************************************************************************************/\n\n\n/// @title Optimized overflow and underflow safe math operations\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\nlibrary LowGasSafeMath {\n    /// @notice Returns x + y, reverts if sum overflows uint256\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n\n    /// @notice Returns x + y, reverts if sum overflows uint256\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(uint256 x, uint256 y, string memory errorMessage) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, errorMessage);\n    }\n\n    /// @notice Returns x - y, reverts if underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n\n    /// @notice Returns x - y, reverts if underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(uint256 x, uint256 y, string memory errorMessage) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, errorMessage);\n    }\n\n    /// @notice Returns x * y, reverts if overflows\n    /// @param x The multiplicand\n    /// @param y The multiplier\n    /// @return z The product of x and y\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(x == 0 || (z = x * y) / x == y);\n    }\n\n    /// @notice Returns x * y, reverts if overflows\n    /// @param x The multiplicand\n    /// @param y The multiplier\n    /// @return z The product of x and y\n    function mul(uint256 x, uint256 y, string memory errorMessage) internal pure returns (uint256 z) {\n        require(x == 0 || (z = x * y) / x == y, errorMessage);\n    }\n}\n"
    },
    "contracts/libraries/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/************************************************************************************************\nOriginally from https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/libraries/SafeCast.sol\n\nThis source code has been modified from the original, which was copied from the github repository\nat commit hash b83fcf497e895ae59b97c9d04e997023f69b5e97.\n\nSubject to the GPL-2.0-or-later license\n*************************************************************************************************/\n\n\n/// @title Safe casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeCast {\n  /// @notice Cast a uint256 to a uint160, revert on overflow\n  /// @param y The uint256 to be downcasted\n  /// @return z The downcasted integer, now type uint160\n  function toUint160(uint256 y) internal pure returns (uint160 z) {\n    require((z = uint160(y)) == y);\n  }\n\n  /// @notice Cast a uint256 to a uint128, revert on overflow\n  /// @param y The uint256 to be downcasted\n  /// @return z The downcasted integer, now type uint128\n  function toUint128(uint256 y) internal pure returns (uint128 z) {\n    require((z = uint128(y)) == y);\n  }\n\n  /// @notice Cast a int256 to a int128, revert on overflow or underflow\n  /// @param y The int256 to be downcasted\n  /// @return z The downcasted integer, now type int128\n  function toInt128(int256 y) internal pure returns (int128 z) {\n    require((z = int128(y)) == y);\n  }\n\n  /// @notice Cast a uint256 to a int256, revert on overflow\n  /// @param y The uint256 to be casted\n  /// @return z The casted integer, now type int256\n  function toInt256(uint256 y) internal pure returns (int256 z) {\n    require(y < 2**255);\n    z = int256(y);\n  }\n\n  /// @notice Cast an int256 to a uint256, revert on overflow\n  /// @param y The uint256 to be downcasted\n  /// @return z The downcasted integer, now type uint160\n  function toUint256(int256 y) internal pure returns (uint256 z) {\n    require(y >= 0);\n    z = uint256(y);\n  }\n}\n"
    },
    "contracts/interfaces/IAbstractDividends.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\n\ninterface IAbstractDividends {\n\t/**\n\t * @dev Returns the total amount of dividends a given address is able to withdraw.\n\t * @param account Address of a dividend recipient\n\t * @return A uint256 representing the dividends `account` can withdraw\n\t */\n\tfunction withdrawableDividendsOf(address account) external view returns (uint256);\n\n  /**\n\t * @dev View the amount of funds that an address has withdrawn.\n\t * @param account The address of a token holder.\n\t * @return The amount of funds that `account` has withdrawn.\n\t */\n\tfunction withdrawnDividendsOf(address account) external view returns (uint256);\n\n\t/**\n\t * @dev View the amount of funds that an address has earned in total.\n\t * accumulativeFundsOf(account) = withdrawableDividendsOf(account) + withdrawnDividendsOf(account)\n\t * = (pointsPerShare * balanceOf(account) + pointsCorrection[account]) / POINTS_MULTIPLIER\n\t * @param account The address of a token holder.\n\t * @return The amount of funds that `account` has earned in total.\n\t */\n\tfunction cumulativeDividendsOf(address account) external view returns (uint256);\n\n\t/**\n\t * @dev This event emits when new funds are distributed\n\t * @param by the address of the sender who distributed funds\n\t * @param dividendsDistributed the amount of funds received for distribution\n\t */\n\tevent DividendsDistributed(address indexed by, uint256 dividendsDistributed);\n\n\t/**\n\t * @dev This event emits when distributed funds are withdrawn by a token holder.\n\t * @param by the address of the receiver of funds\n\t * @param fundsWithdrawn the amount of funds that were withdrawn\n\t */\n\tevent DividendsWithdrawn(address indexed by, uint256 fundsWithdrawn);\n}"
    },
    "contracts/base/ERC20Dividends.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"./ERC20VotesComp.sol\";\nimport \"./AbstractDividends.sol\";\n\n\ncontract ERC20Dividends is ERC20VotesComp, AbstractDividends {\n  constructor(string memory name, string memory symbol)\n    ERC20VotesComp(name, symbol)\n    AbstractDividends(balanceOf, totalSupply)\n  {}\n\n\t/**\n\t * @dev Internal function that transfer tokens from one address to another.\n\t * Update pointsCorrection to keep funds unchanged.\n\t * @param from The address to transfer from.\n\t * @param to The address to transfer to.\n\t * @param value The amount to be transferred.\n\t */\n\tfunction _transfer(address from, address to, uint96 value) internal virtual override {\n\t\tsuper._transfer(from, to, value);\n    _correctPointsForTransfer(from, to, value);\n\t}\n\n\t/**\n\t * @dev Internal function that mints tokens to an account.\n\t * Update pointsCorrection to keep funds unchanged.\n\t * @param account The account that will receive the created tokens.\n\t * @param amount The amount that will be created.\n\t */\n\tfunction _mint(address account, uint256 amount) internal virtual override {\n\t\tsuper._mint(account, amount);\n    _correctPoints(account, -int256(amount));\n\t}\n\t\n\t/** \n\t * @dev Internal function that burns an amount of the token of a given account.\n\t * Update pointsCorrection to keep funds unchanged.\n\t * @param account The account whose tokens will be burnt.\n\t * @param amount The amount that will be burnt.\n\t */\n\tfunction _burn(address account, uint256 amount) internal virtual override {\n\t\tsuper._burn(account, amount);\n    _correctPoints(account, int256(amount));\n\t}\n}"
    },
    "contracts/base/ERC20VotesComp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma abicoder v2;\n\nimport \"../interfaces/IERC20VotesComp.sol\";\n\n\ncontract ERC20VotesComp is IERC20VotesComp {\n/** ========== Constants ==========  */\n\n  /** @dev The EIP-712 typehash for the contract's domain */\n  bytes32 public constant DOMAIN_TYPEHASH =\n    keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n  /** @dev The EIP-712 typehash for the delegation struct used by the contract */\n  bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n  /** @dev The EIP-712 typehash for the permit struct used by the contract */\n  bytes32 public constant PERMIT_TYPEHASH = keccak256(\n    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n  );\n\n  /** @dev The EIP-712 domain separator */\n  bytes32 public immutable domainSeparator;\n\n  /** @dev EIP-20 token decimals for this token */\n  uint8 public constant decimals = 18;\n\n  /** @dev EIP-20 token name for this token */\n  string public name;\n\n  /** @dev EIP-20 token symbol for this token */\n  string public symbol;\n\n/** ========== Storage ==========  */\n\n  /** @dev Total number of tokens in circulation */\n  uint96 internal _totalSupply;\n\n  /** @dev Allowance amounts on behalf of others */\n  mapping(address => mapping(address => uint96)) internal allowances;\n\n  /** @dev Official record of token balances for each account */\n  mapping(address => uint96) internal balances;\n\n  /** @dev A record of each accounts delegate */\n  mapping(address => address) public override delegates;\n\n  /** @dev A record of votes checkpoints for each account, by index */\n  mapping(address => mapping(uint32 => Checkpoint)) public override checkpoints;\n\n  /** @dev The number of checkpoints for each account */\n  mapping(address => uint32) public override numCheckpoints;\n\n  /** @dev A record of states for signing / validating signatures */\n  mapping(address => uint256) public override nonces;\n\n/** ========== Constructor ==========  */\n\n  constructor(string memory _name, string memory _symbol) {\n    name = _name;\n    symbol = _symbol;\n    domainSeparator = keccak256(abi.encode(\n      DOMAIN_TYPEHASH, keccak256(bytes(_name)), getChainId(), address(this)\n    ));\n  }\n\n/** ========== Queries ==========  */\n\n  function totalSupply() public view override returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n   * @dev Get the number of tokens `spender` is approved to spend on behalf of `account`\n   * @param account The address of the account holding the funds\n   * @param spender The address of the account spending the funds\n   * @return The number of tokens approved\n   */\n  function allowance(address account, address spender) public view override returns (uint256) {\n    return allowances[account][spender];\n  }\n\n  /**\n   * @dev Get the number of tokens held by the `account`\n   * @param account The address of the account to get the balance of\n   * @return The number of tokens held\n   */\n  function balanceOf(address account) public view override returns (uint256) {\n    return balances[account];\n  }\n\n  /**\n   * @dev Gets the current votes balance for `account`\n   * @param account The address to get votes balance\n   * @return The number of current votes for `account`\n   */\n  function getCurrentVotes(address account) external view override returns (uint96) {\n    uint32 nCheckpoints = numCheckpoints[account];\n    return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n  }\n\n  /**\n   * @dev Determine the prior number of votes for an account as of a block number\n   * Block number must be a finalized block or else this function will revert to prevent misinformation.\n   * @param account The address of the account to check\n   * @param blockNumber The block number to get the vote balance at\n   * @return The number of votes the account had as of the given block\n   */\n  function getPriorVotes(address account, uint256 blockNumber) external view override returns (uint96) {\n    require(blockNumber < block.number, \"not yet determined\");\n\n    uint32 nCheckpoints = numCheckpoints[account];\n    if (nCheckpoints == 0) {\n      return 0;\n    }\n\n    // First check most recent balance\n    if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n      return checkpoints[account][nCheckpoints - 1].votes;\n    }\n\n    // Next check implicit zero balance\n    if (checkpoints[account][0].fromBlock > blockNumber) {\n      return 0;\n    }\n\n    uint32 lower = 0;\n    uint32 upper = nCheckpoints - 1;\n    while (upper > lower) {\n      uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n      Checkpoint memory cp = checkpoints[account][center];\n      if (cp.fromBlock == blockNumber) {\n        return cp.votes;\n      } else if (cp.fromBlock < blockNumber) {\n        lower = center;\n      } else {\n        upper = center - 1;\n      }\n    }\n    return checkpoints[account][lower].votes;\n  }\n\n/** ========== ERC20 Actions ==========  */\n\n  /**\n   * @dev Approve `spender` to transfer up to `amount` from `src`\n   * This will overwrite the approval amount for `spender`\n   *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n   * @param spender The address of the account which may transfer tokens\n   * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n   * @return Whether or not the approval succeeded\n   */\n  function approve(address spender, uint256 rawAmount) external override returns (bool) {\n    uint96 amount;\n    if (rawAmount == uint256(-1)) {\n      amount = uint96(-1);\n    } else {\n      amount = safe96(rawAmount);\n    }\n\n    allowances[msg.sender][spender] = amount;\n\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 rawAmount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    uint96 amount;\n    if (rawAmount == uint256(-1)) {\n      amount = uint96(-1);\n    } else {\n      amount = safe96(rawAmount);\n    }\n\n    bytes32 structHash = keccak256(\n      abi.encode(\n        PERMIT_TYPEHASH,\n        owner,\n        spender,\n        rawAmount,\n        nonces[owner]++,\n        deadline\n      )\n    );\n    bytes32 digest = keccak256(\n      abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n    );\n    address signatory = ecrecover(digest, v, r, s);\n    require(signatory != address(0), \"invalid signature\");\n    require(signatory == owner, \"unauthorized\");\n    require(block.timestamp <= deadline, \"signature expired\");\n\n    allowances[owner][spender] = amount;\n\n    emit Approval(owner, spender, amount);\n  }\n\n  /**\n   * @dev Transfer `amount` tokens from `msg.sender` to `dst`\n   * @param dst The address of the destination account\n   * @param rawAmount The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transfer(address dst, uint256 rawAmount) external override returns (bool) {\n    uint96 amount = safe96(rawAmount);\n    _transfer(msg.sender, dst, amount);\n    return true;\n  }\n\n  /**\n   * @dev Transfer `amount` tokens from `src` to `dst`\n   * @param src The address of the source account\n   * @param dst The address of the destination account\n   * @param rawAmount The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 rawAmount\n  ) external override returns (bool) {\n    address spender = msg.sender;\n    uint96 spenderAllowance = allowances[src][spender];\n    uint96 amount = safe96(rawAmount);\n\n    if (spender != src && spenderAllowance != uint96(-1)) {\n      uint96 newAllowance =\n        sub96(spenderAllowance, amount, \"transfer amount exceeds allowance\");\n      allowances[src][spender] = newAllowance;\n\n      emit Approval(src, spender, newAllowance);\n    }\n\n    _transfer(src, dst, amount);\n    return true;\n  }\n\n/** ========== Delegation Actions ==========  */\n\n  /**\n   * @dev Delegate votes from `msg.sender` to `delegatee`\n   * @param delegatee The address to delegate votes to\n   */\n  function delegate(address delegatee) external override {\n    return _delegate(msg.sender, delegatee);\n  }\n\n  /**\n   * @dev Delegates votes from signatory to `delegatee`\n   * @param delegatee The address to delegate votes to\n   * @param nonce The contract state required to match the signature\n   * @param expiry The time at which to expire the signature\n   * @param v The recovery byte of the signature\n   * @param r Half of the ECDSA signature pair\n   * @param s Half of the ECDSA signature pair\n   */\n  function delegateBySig(\n    address delegatee,\n    uint256 nonce,\n    uint256 expiry,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external override {\n    bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n    bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    address signatory = ecrecover(digest, v, r, s);\n    require(signatory != address(0), \"invalid signature\");\n    require(nonce == nonces[signatory]++, \"invalid nonce\");\n    require(block.timestamp <= expiry, \"signature expired\");\n    return _delegate(signatory, delegatee);\n  }\n\n/** ========== Internal Helpers ==========  */\n\n  function _mint(address dst, uint256 rawAmount) internal virtual {\n    require(dst != address(0), \"mint to the zero address\");\n    uint96 amount = safe96(rawAmount);\n    _totalSupply = add96(_totalSupply, amount, \"mint amount overflows\");\n    balances[dst] += amount; // add96 not needed because totalSupply does not overflow\n    emit Transfer(address(0), dst, amount);\n    _moveDelegates(address(0), delegates[dst], amount);\n  }\n\n  function _burn(address src, uint256 rawAmount) internal virtual {\n    require(src != address(0), \"burn from the zero address\");\n    uint96 amount = safe96(rawAmount);\n    balances[src] = sub96(balances[src], amount, \"burn amount exceeds balance\");\n    _totalSupply -= amount; // add96 not needed because balance does not underflow\n    emit Transfer(src, address(0), amount);\n    _moveDelegates(delegates[src], address(0), amount);\n  }\n\n  function _delegate(address delegator, address delegatee) internal {\n    address currentDelegate = delegates[delegator];\n    uint96 delegatorBalance = balances[delegator];\n    delegates[delegator] = delegatee;\n    emit DelegateChanged(delegator, currentDelegate, delegatee);\n    _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n  }\n\n  function _transfer(\n    address src,\n    address dst,\n    uint96 amount\n  ) internal virtual {\n    require(src != address(0), \"transfer from the zero address\");\n    require(dst != address(0), \"transfer to the zero address\");\n\n    balances[src] = sub96(balances[src], amount, \"transfer amount exceeds balance\");\n    balances[dst] = add96(balances[dst], amount, \"transfer amount overflows\");\n    emit Transfer(src, dst, amount);\n\n    _moveDelegates(delegates[src], delegates[dst], amount);\n  }\n\n  function _moveDelegates(\n    address srcRep,\n    address dstRep,\n    uint96 amount\n  ) internal {\n    if (srcRep != dstRep && amount > 0) {\n      if (srcRep != address(0)) {\n        uint32 srcRepNum = numCheckpoints[srcRep];\n        uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n        uint96 srcRepNew = sub96(srcRepOld, amount, \"vote amount underflows\");\n        _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n      }\n\n      if (dstRep != address(0)) {\n        uint32 dstRepNum = numCheckpoints[dstRep];\n        uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n        uint96 dstRepNew = add96(dstRepOld, amount, \"vote amount overflows\");\n        _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n      }\n    }\n  }\n\n  function _writeCheckpoint(\n    address delegatee,\n    uint32 nCheckpoints,\n    uint96 oldVotes,\n    uint96 newVotes\n  ) internal {\n    uint32 blockNumber = safe32(block.number, \"block number exceeds 32 bits\");\n\n    if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n      checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n    } else {\n      checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n      numCheckpoints[delegatee] = nCheckpoints + 1;\n    }\n\n    emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n  }\n\n  function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n    require(n < 2**32, errorMessage);\n    return uint32(n);\n  }\n\n  function safe96(uint256 n) internal pure returns (uint96) {\n    require(n < 2**96, \"amount exceeds 96 bits\");\n    return uint96(n);\n  }\n\n  function add96(\n    uint96 a,\n    uint96 b,\n    string memory errorMessage\n  ) internal pure returns (uint96) {\n    uint96 c = a + b;\n    require(c >= a, errorMessage);\n    return c;\n  }\n\n  function sub96(\n    uint96 a,\n    uint96 b,\n    string memory errorMessage\n  ) internal pure returns (uint96) {\n    require(b <= a, errorMessage);\n    return a - b;\n  }\n\n  function getChainId() internal pure returns (uint256) {\n    uint256 chainId;\n    assembly { chainId := chainid() }\n    return chainId;\n  }\n}\n"
    },
    "contracts/interfaces/IERC20VotesComp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"./IERC20.sol\";\n\n\ninterface IERC20VotesComp is IERC20 {\n  event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n  event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n  struct Checkpoint {\n    uint32 fromBlock;\n    uint96 votes;\n  }\n\n  function nonces(address) external view returns (uint256);\n\n  function delegates(address) external view returns (address);\n\n  function checkpoints(address, uint32) external view returns (uint32 fromBlock, uint96 votes);\n\n  function numCheckpoints(address) external view returns (uint32);\n\n  function getCurrentVotes(address account) external view returns (uint96);\n\n  function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96);\n\n  function delegate(address delegatee) external;\n\n  function delegateBySig(\n    address delegatee,\n    uint256 nonce,\n    uint256 expiry,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n}"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/test/TestERC20Dividends.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../base/ERC20Dividends.sol\";\n\n\ncontract TestERC20Dividends is ERC20Dividends {\n  constructor() ERC20Dividends(\"ERC20Dividends\", \"DIV\") {}\n\n  function mint(address account, uint256 amount) external {\n    _mint(account, amount);\n  }\n\n  function burn(address account, uint256 amount) external {\n    _burn(account, amount);\n  }\n\n  function distributeDividends(uint256 amount) external {\n    _distributeDividends(amount);\n  }\n\n  function getPointsCorrection(address account) external view returns (int256) {\n    return pointsCorrection[account];\n  }\n\n  function getWithdrawnDividends(address account) external view returns (uint256) {\n    return withdrawnDividendsOf(account);\n  }\n\n  function prepareCollect(address account) external returns (uint256) {\n    return _prepareCollect(account);\n  }\n}"
    },
    "contracts/ERC20DividendsOwned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./base/ERC20Dividends.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./interfaces/IWETH.sol\";\n\n\ncontract ERC20DividendsOwned is ERC20Dividends, Ownable {\n  using TransferHelper for address;\n\n  address public immutable weth;\n\n  receive() external payable { return; }\n\n  constructor(\n    address weth_,\n    string memory name_,\n    string memory symbol_\n  ) ERC20Dividends(name_, symbol_) Ownable() {\n    weth = weth_;\n  }\n\n  function mint(address to, uint256 amount) external onlyOwner {\n    _mint(to, amount);\n  }\n\n  function burn(address from, uint256 amount) external onlyOwner {\n    _burn(from, amount);\n  }\n\n  function collect() external {\n    uint256 amount = _prepareCollect(msg.sender);\n    weth.safeTransfer(msg.sender, amount);\n  }\n\n  function collectETH() external {\n    uint256 amount = _prepareCollect(msg.sender);\n    IWETH(weth).withdraw(amount);\n    address(msg.sender).safeTransferETH(amount);\n  }\n\n  function distribute(uint256 amount) external {\n    weth.safeTransferFrom(msg.sender, address(this), amount);\n    _distributeDividends(amount);\n  }\n\n  function distribute() external payable {\n    IWETH(weth).deposit{value: msg.value}();\n    _distributeDividends(msg.value);\n  }\n}"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.0;\n\nimport \"../interfaces/IERC20.sol\";\n/************************************************************************************************\nOriginally from https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/TransferHelper.sol\n\nThis source code has been modified from the original, which was copied from the github repository\nat commit hash 6a31c618fc3180a6ee945b869d1ce4449f253ee6.\n\nSubject to the GPL-2.0-or-later license\n*************************************************************************************************/\n\n\nlibrary TransferHelper {\n  function safeTransferFrom(\n    address token,\n    address from,\n    address to,\n    uint256 value\n  ) internal {\n    (bool success, bytes memory data) =\n      token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n    require(success && (data.length == 0 || abi.decode(data, (bool))), \"STF\");\n  }\n\n  function safeTransfer(\n    address token,\n    address to,\n    uint256 value\n  ) internal {\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n    require(success && (data.length == 0 || abi.decode(data, (bool))), \"ST\");\n  }\n\n  function safeTransferETH(address to, uint256 value) internal {\n    (bool success, ) = to.call{value: value}(new bytes(0));\n    require(success, \"STE\");\n  }\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\n\ninterface IWETH {\n  function deposit() external payable;\n  function withdraw(uint) external;\n}"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/test/TestERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../base/ERC20VotesComp.sol\";\nimport \"../libraries/TransferHelper.sol\";\n\n\ncontract TestERC20 is ERC20VotesComp {\n  using TransferHelper for address;\n\n  event Delegate(address indexed delegator, address indexed delegatee);\n\n  constructor(string memory name_, string memory symbol_) ERC20VotesComp(name_, symbol_) {}\n\n  function mint(address account, uint256 amount) external {\n    _mint(account, amount);\n  }\n\n  function burn(address account, uint256 amount) public {\n    _burn(account, amount);\n  }\n\n  function transferInternal(address from, address to, uint96 value) public {\n    _transfer(from, to, value);\n  }\n\n  function deposit() external payable {\n    _mint(msg.sender, msg.value);\n  }\n\n  function withdraw(uint256 amount) external {\n    _burn(msg.sender, amount);\n    address(msg.sender).safeTransferETH(amount);\n  }\n}"
    },
    "contracts/base/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"../interfaces/IERC20.sol\";\n\n\n/************************************************************************************************\nOriginally from https://github.com/boringcrypto/BoringSolidity/blob/master/contracts/ERC20.sol\n\nThis source code has been modified from the original, which was copied from the github repository\nat commit hash 8f2b54f645a7844ae266cc50dc3ae4c125c7b9fc.\n\nSubject to the MIT license\n*************************************************************************************************/\n\ncontract ERC20 is IERC20 {\n  /**\n   * @dev The amount of tokens in existence.\n   */\n  uint256 public override totalSupply;\n  /**\n   * @dev The amount of tokens owned by `account`.\n   */\n  mapping(address => uint256) public override balanceOf;\n  /**\n   * @dev The remaining number of tokens that `spender` will be allowed\n   * to spend on behalf of `owner` through {transferFrom}. This is zero\n   * by default.\n   */\n  mapping(address => mapping(address => uint256)) public override allowance;\n\n  /** @dev The name of the token. */\n  string public name;\n\n  /** @dev The symbol of the token. */\n  string public symbol;\n\n  /**\n   * @dev Returns the number of decimals used to get its user representation.\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\n   * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n   *\n   * Tokens usually opt for a value of 18, imitating the relationship between\n   * Ether and Wei. This is the value {ERC20} uses, unless this function is\n   * overridden;\n   *\n   * NOTE: This information is only used for _display_ purposes: it in\n   * no way affects any of the arithmetic of the contract, including\n   * {balanceOf} and {transfer}.\n   */\n  uint8 public immutable decimals;\n\n  constructor(\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  ) {\n    name = name_;\n    symbol = symbol_;\n    decimals = decimals_;\n  }\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   *\n   * Requirements:\n   *\n   * - `recipient` cannot be the zero address.\n   * - the caller must have a balance of at least `amount`.\n   */\n  function transfer(address to, uint256 amount) external virtual override returns (bool) {\n    _transfer(msg.sender, to, amount);\n    return true;\n  }\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits an {Approval} event indicating the updated allowance. This is not\n   * required by the EIP. See the note at the beginning of {ERC20}.\n   *\n   * Requirements:\n   *\n   * - `sender` and `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   * - the caller must have allowance for `sender`'s tokens of at least\n   * `amount`.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external override returns (bool) {\n    _transfer(sender, recipient, amount);\n\n    uint256 spenderAllowance = allowance[sender][msg.sender];\n    require(spenderAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n\n    _approve(sender, msg.sender, spenderAllowance - amount);\n    return true;\n  }\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function approve(address spender, uint256 amount) external override returns (bool) {\n    _approve(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @dev Moves tokens `amount` from `sender` to `recipient`.\n   *\n   * This is internal function is equivalent to {transfer}, and can be used to\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\n   *\n   * Emits a {Transfer} event.\n   *\n   * Requirements:\n   *\n   * - `sender` cannot be the zero address.\n   * - `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   */\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) internal virtual {\n    require(sender != address(0), \"ERC20: transfer from the zero address\");\n    // If `amount` is 0, or `msg.sender` is `to` nothing happens\n    if (amount != 0) {\n      uint256 srcBalance = balanceOf[sender];\n      require(srcBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n      if (sender != recipient) {\n        require(recipient != address(0), \"ERC20: transfer to the zero address\"); // Moved down so low balance calls safe some gas\n        balanceOf[sender] = srcBalance - amount; // Underflow is checked\n        balanceOf[recipient] += amount; // Can't overflow because totalSupply would be greater than 2^256-1\n      }\n    }\n\n    emit Transfer(sender, recipient, amount);\n  }\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n   *\n   * This internal function is equivalent to `approve`, and can be used to\n   * e.g. set automatic allowances for certain subsystems, etc.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n    allowance[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n   * the total supply.\n   *\n   * Emits a {Transfer} event with `from` set to the zero address.\n   *\n   * Requirements:\n   *\n   * - `account` cannot be the zero address.\n   */\n  function _mint(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: mint to the zero address\");\n    require((totalSupply = totalSupply + amount) >= amount);\n    balanceOf[account] += amount;\n    emit Transfer(address(0), account, amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, reducing the\n   * total supply.\n   *\n   * Emits a {Transfer} event with `to` set to the zero address.\n   *\n   * Requirements:\n   *\n   * - `account` cannot be the zero address.\n   * - `account` must have at least `amount` tokens.\n   */\n  function _burn(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: burn from the zero address\");\n    uint256 supply = totalSupply;\n    uint256 balance = balanceOf[account];\n    require((balanceOf[account] = balance - amount) <= balance, \"ERC20: burn amount exceeds balance\");\n    require((totalSupply = supply - amount) <= supply);\n\n    emit Transfer(account, address(0), amount);\n  }\n}\n"
    },
    "contracts/interfaces/IERC20Metadata.sol": {
      "content": " // SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\nimport \"./IERC20.sol\";\n\n\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}"
    },
    "contracts/interfaces/IERC20Dividends.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"./IERC20Metadata.sol\";\n\n\ninterface IERC20Dividends is IERC20Metadata {\n\t/**\n\t * @dev Returns the total amount of dividends a given address is able to withdraw currently.\n\t * @param owner Address of FundsDistributionToken holder\n\t * @return A uint256 representing the available funds for a given account\n\t */\n\tfunction withdrawableDividendsOf(address owner) external view returns (uint256);\n\n\t/**\n\t * @dev This event emits when new funds are distributed\n\t * @param by the address of the sender who distributed funds\n\t * @param dividendsDistributed the amount of funds received for distribution\n\t */\n\tevent DividendsDistributed(address indexed by, uint256 dividendsDistributed);\n\n\t/**\n\t * @dev This event emits when distributed funds are withdrawn by a token holder.\n\t * @param by the address of the receiver of funds\n\t * @param fundsWithdrawn the amount of funds that were withdrawn\n\t */\n\tevent DividendsWithdrawn(address indexed by, uint256 fundsWithdrawn);\n}"
    },
    "contracts/interfaces/IERC20Delegatable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"./IERC20Metadata.sol\";\n\n\ninterface IERC20Delegatable is IERC20Metadata {\n  function delegate(address delegatee) external;\n}"
    },
    "contracts/base/SubDelegationModuleImplementation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"../interfaces/IERC20Delegatable.sol\";\n\n\n/**\n * @dev This is a work-around for the delegation mechanic in COMP.\n * It allows the balance of a staked governance token to be held in separate wallets\n * for each user who makes a deposit so that they will retain the ability to control\n * their governance delegation individually.\n *\n * This is an implementation contract that should be used for a separate proxy per user.\n */\ncontract SubDelegationModuleImplementation {\n  IERC20Delegatable public immutable token;\n  address public immutable module;\n\n\n  constructor(address _token) {\n    token = IERC20Delegatable(_token);\n    module = msg.sender;\n  }\n\n  function delegate(address to) external {\n    require(msg.sender == module, \"!module\");\n    token.delegate(to);\n  }\n\n  function transfer(address to, uint256 amount) external {\n    require(msg.sender == module, \"!module\");\n    token.transfer(to, amount);\n  }\n}"
    },
    "contracts/base/DelegationModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n/* ---  External Libraries  --- */\nimport { Create2 } from \"@openzeppelin/contracts/utils/Create2.sol\";\nimport \"../libraries/TransferHelper.sol\";\nimport \"../libraries/CloneLibrary.sol\";\nimport \"./SubDelegationModuleImplementation.sol\";\nimport \"../interfaces/IDelegationModule.sol\";\n\n\ncontract DelegationModule is IDelegationModule {\n  using TransferHelper for address;\n  address public immutable override moduleImplementation;\n  address public immutable override depositToken;\n\n  /**\n   * @dev Contains the address of the sub-delegation module for a user\n   * if one has been deployed.\n   */\n  mapping(address => ISubDelegationModule) public override subDelegationModuleForUser;\n\n  constructor(address depositToken_) {\n    depositToken = depositToken_;\n    moduleImplementation = address(new SubDelegationModuleImplementation(depositToken_));\n  }\n\n  function getOrCreateModule(address account) internal returns (ISubDelegationModule module) {\n    module = subDelegationModuleForUser[account];\n    if (address(module) == address(0)) {\n      module = ISubDelegationModule(CloneLibrary.createClone(moduleImplementation));\n      subDelegationModuleForUser[account] = module;\n      module.delegate(account);\n      emit SubDelegationModuleCreated(account, address(module));\n    }\n  }\n\n  /**\n   * @dev Send `amount` of the delegatable token to the sub-delegation\n   * module for `account`. \n   */\n  function _depositToModule(address account, uint256 amount) internal {\n    ISubDelegationModule module = getOrCreateModule(account);\n    depositToken.safeTransferFrom(account, address(module), amount);\n  }\n\n  /**\n   * @dev Withdraw the full balance of the delegatable token from the\n   * sub-delegation module for `account` to `to`.\n   */\n  function _withdrawFromModule(address account, address to, uint256 amount) internal {\n    ISubDelegationModule module = subDelegationModuleForUser[account];\n    module.transfer(to, amount);\n  }\n\n  /**\n   * @dev Delegates the balance of the sub-delegation module for `account`\n   * to `delegatee`.\n   */\n  function _delegateFromModule(address account, address delegatee) internal {\n    ISubDelegationModule module = subDelegationModuleForUser[account];\n    module.delegate(delegatee);\n  }\n}"
    },
    "@openzeppelin/contracts/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address) {\n        address addr;\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n        return addr;\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address) {\n        bytes32 _data = keccak256(\n            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash)\n        );\n        return address(uint160(uint256(_data)));\n    }\n}\n"
    },
    "contracts/libraries/CloneLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\n/*\nThe MIT License (MIT)\nCopyright (c) 2018 Murray Software, LLC.\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/**\n * EIP 1167 Proxy Deployment\n * Originally from https://github.com/optionality/clone-factory/\n */\nlibrary CloneLibrary {\n  function createClone(address target) internal returns (address result) {\n    // Reserve 55 bytes for the deploy code + 17 bytes as a buffer to prevent overwriting\n    // other memory in the final mstore\n    bytes memory createCode = new bytes(72);\n    assembly {\n      let clone := add(createCode, 32)\n      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(clone, 0x14), shl(96, target))\n      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n      result := create(0, clone, 0x37)\n    }\n  }\n\n  function isClone(address target, address query) internal view returns (bool result) {\n    assembly {\n      let clone := mload(0x40)\n      mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\n      mstore(add(clone, 0xa), shl(96, target))\n      mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n\n      let other := add(clone, 0x40)\n      extcodecopy(query, other, 0, 0x2d)\n      result := and(\n        eq(mload(clone), mload(other)),\n        eq(mload(add(clone, 0xd)), mload(add(other, 0xd)))\n      )\n    }\n  }\n}"
    },
    "contracts/interfaces/IDelegationModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\nimport \"./ISubDelegationModule.sol\";\n\n\ninterface IDelegationModule {\n  event SubDelegationModuleCreated(address indexed account, address module);\n\n  function moduleImplementation() external view returns (address);\n\n  function depositToken() external view returns (address);\n\n  function subDelegationModuleForUser(address) external view returns (ISubDelegationModule);\n}"
    },
    "contracts/interfaces/ISubDelegationModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n\ninterface ISubDelegationModule {\n  function delegate(address to) external;\n  function transfer(address to, uint256 amount) external;\n}"
    },
    "contracts/test/TestDelegationModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"../base/DelegationModule.sol\";\n\n\ncontract TestDelegationModule is DelegationModule {\n  constructor(address depositToken_) DelegationModule(depositToken_) {}\n\n  function depositToModule(address account, uint256 amount) external {\n    _depositToModule(account, amount);\n  }\n\n  function withdrawFromModule(address account, address to, uint256 amount) external {\n    _withdrawFromModule(account, to, amount);\n  }\n\n  function delegateFromModule(address account, address delegatee) external {\n    _delegateFromModule(account, delegatee);\n  }\n\n  function getOrCreateModuleInternal(address account) external {\n    getOrCreateModule(account);\n  }\n}"
    },
    "contracts/SharesTimeLock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./base/DelegationModule.sol\";\nimport \"./libraries/LowGasSafeMath.sol\";\nimport \"./interfaces/ISharesTimeLock.sol\";\n\n\ncontract SharesTimeLock is ISharesTimeLock, DelegationModule, Ownable() {\n  using LowGasSafeMath for uint256;\n  using TransferHelper for address;\n\n/** ========== Constants ==========  */\n\n  /**\n   * @dev Token used for dividend payments and given to users for deposits.\n   * Must be an ERC20DividendsOwned with this contract set as the owner.\n   */\n  address public immutable override dividendsToken;\n\n  /**\n   * @dev Minimum number of seconds shares can be locked for.\n   */\n  uint32 public immutable override minLockDuration;\n\n  /**\n   * @dev Maximum number of seconds shares can be locked for.\n   */\n  uint32 public immutable override maxLockDuration;\n\n  /**\n   * @dev Minimum early withdrawal fee added to every dynamic withdrawal fee.\n   */\n  uint256 public immutable override minEarlyWithdrawalFee;\n\n  /**\n   * @dev Base early withdrawal fee expressed as a fraction of 1e18.\n   * This is the fee paid if tokens are withdrawn immediately after being locked.\n   * It is multiplied by the dividend multiplier, and added to the minimum early withdrawal fee.\n   */\n  uint256 public immutable override baseEarlyWithdrawalFee;\n\n  /**\n   * @dev Maximum dividends multiplier for a lock duration of `maxLockDuration`\n   */\n  uint256 public immutable override maxDividendsBonusMultiplier;\n\n/** ========== Storage ==========  */\n\n  /**\n   * @dev Array of token locks.\n   */\n  Lock[] public override locks;\n\n  /**\n   * @dev Account which receives fees taken for early withdrawals.\n   */\n  address public override feeRecipient;\n\n  /**\n   * @dev Minimum amount of tokens that can be deposited.\n   * If zero, there is no minimum.\n   */\n  uint96 public override minimumDeposit;\n\n  /**\n   * @dev Accumulated early withdrawal fees.\n   */\n  uint96 public override pendingFees;\n\n  /**\n   * @dev Allows all locked tokens to be withdrawn with no fees.\n   */\n  bool public override emergencyUnlockTriggered;\n\n/** ========== Queries ==========  */\n\n  /**\n   * @dev Returns the number of locks that have been created.\n   */\n  function getLocksLength() external view override returns (uint256) {\n    return locks.length;\n  }\n\n  /**\n   * @dev Returns the dividends multiplier for `duration` expressed as a fraction of 1e18.\n   */\n  function getDividendsMultiplier(uint256 duration) public view override returns (uint256 multiplier) {\n    require(duration >= minLockDuration && duration <= maxLockDuration, \"OOB\");\n    uint256 durationRange = maxLockDuration - minLockDuration;\n    uint256 overMinimum = duration - minLockDuration;\n    return uint256(1e18).add(\n      maxDividendsBonusMultiplier.mul(overMinimum) / durationRange\n    );\n  }\n\n  /**\n   * @dev Returns the withdrawal fee and withdrawable shares for a withdrawal of a\n   * lock created at `lockedAt` with a duration of `lockDuration`, if it was withdrawan\n   * now.\n   *\n   * The early withdrawal fee is 0 if the full duration has passed or the emergency unlock\n   * has been triggered; otherwise, it is calculated as the fraction of the total duration\n   * that has not elapsed multiplied by the maximum base withdrawal fee and the dividends\n   * multiplier, plus the minimum withdrawal fee.\n   */\n  function getWithdrawalParameters(\n    uint256 amount,\n    uint256 lockedAt,\n    uint256 lockDuration\n  )\n    public\n    view\n    override\n    returns (uint256 dividendShares, uint256 earlyWithdrawalFee)\n  {\n    uint256 multiplier = getDividendsMultiplier(lockDuration);\n    dividendShares = amount.mul(multiplier) / uint256(1e18);\n    uint256 unlockAt = lockedAt + lockDuration;\n    if (block.timestamp >= unlockAt || emergencyUnlockTriggered) {\n      earlyWithdrawalFee = 0;\n    } else {\n      uint256 timeRemaining = unlockAt - block.timestamp;\n      uint256 minimumFee = amount.mul(minEarlyWithdrawalFee) / uint256(1e18);\n      uint256 dynamicFee = amount.mul(\n        baseEarlyWithdrawalFee.mul(timeRemaining).mul(multiplier)\n      ) / uint256(1e36 * lockDuration);\n      earlyWithdrawalFee = minimumFee.add(dynamicFee);\n    }\n  }\n\n/** ========== Constructor ==========  */\n\n  constructor(\n    address depositToken_,\n    address dividendsToken_,\n    uint32 minLockDuration_,\n    uint32 maxLockDuration_,\n    uint256 minEarlyWithdrawalFee_,\n    uint256 baseEarlyWithdrawalFee_,\n    uint256 maxDividendsBonusMultiplier_\n  ) DelegationModule(depositToken_) {\n    dividendsToken = dividendsToken_;\n    require(minLockDuration_ < maxLockDuration_, \"min>=max\");\n    require(\n      minEarlyWithdrawalFee_.add(baseEarlyWithdrawalFee_.mul(maxDividendsBonusMultiplier_)) <= 1e36,\n      \"maxFee\"\n    );\n    minLockDuration = minLockDuration_;\n    maxLockDuration = maxLockDuration_;\n    maxDividendsBonusMultiplier = maxDividendsBonusMultiplier_;\n    minEarlyWithdrawalFee = minEarlyWithdrawalFee_;\n    baseEarlyWithdrawalFee = baseEarlyWithdrawalFee_;\n  }\n\n/** ========== Controls ==========  */\n\n  /**\n   * @dev Trigger an emergency unlock which allows all locked tokens to be withdrawn\n   * with zero fees.\n   */\n  function triggerEmergencyUnlock() external override onlyOwner {\n    require(!emergencyUnlockTriggered, \"already triggered\");\n    emergencyUnlockTriggered = true;\n    emit EmergencyUnlockTriggered();\n  }\n\n  /**\n   * @dev Set the minimum deposit to `minimumDeposit_`. If it is 0, there will be no minimum.\n   */\n  function setMinimumDeposit(uint96 minimumDeposit_) external override onlyOwner {\n    minimumDeposit = minimumDeposit_;\n    emit MinimumDepositSet(minimumDeposit_);\n  }\n\n  /**\n   * @dev Set the account which receives fees taken for early withdrawals.\n   */\n  function setFeeRecipient(address feeRecipient_) external override onlyOwner {\n    feeRecipient = feeRecipient_;\n    emit FeeRecipientSet(feeRecipient_);\n  }\n\n/** ========== Fees ==========  */\n\n  /**\n   * @dev Transfers accumulated early withdrawal fees to the fee recipient.\n   */\n  function distributeFees() external override {\n    address recipient = feeRecipient;\n    require(recipient != address(0), \"no recipient\");\n    uint256 amount = pendingFees;\n    require(amount > 0, \"no fees\");\n    pendingFees = 0;\n    depositToken.safeTransfer(recipient, amount);\n    emit FeesTransferred(amount);\n  }\n\n/** ========== Locks ==========  */\n\n  /**\n   * @dev Lock `amount` of `depositToken` for `duration` seconds.\n   *\n   * Mints an amount of dividend tokens equal to the amount of tokens locked\n   * times 1 + (duration-minDuration) / (maxDuration - minDuration).\n   *\n   * Uses transferFrom - caller must have approved the contract to spend `amount`\n   * of `depositToken`.\n   *\n   * If the emergency unlock has been triggered, deposits will fail.\n   *\n   * `amount` must be greater than `minimumDeposit`.\n   */\n  function deposit(uint256 amount, uint32 duration) external override returns (uint256 lockId) {\n    require(amount >= minimumDeposit, \"min deposit\");\n    require(!emergencyUnlockTriggered, \"deposits blocked\");\n    _depositToModule(msg.sender, amount);\n    uint256 multiplier = getDividendsMultiplier(duration);\n    uint256 dividendShares = amount.mul(multiplier) / 1e18;\n    IERC20DividendsOwned(dividendsToken).mint(msg.sender, dividendShares);\n    lockId = locks.length;\n    locks.push(Lock({\n      amount: amount,\n      lockedAt: uint32(block.timestamp),\n      lockDuration: duration,\n      owner: msg.sender\n    }));\n    emit LockCreated(\n      lockId,\n      msg.sender,\n      amount,\n      dividendShares,\n      duration\n    );\n  }\n\n  /**\n   * @dev Withdraw the tokens locked in `lockId`.\n   * The caller will incur an early withdrawal fee if the lock duration has not elapsed.\n   * All of the dividend tokens received when the lock was created will be burned from the\n   * caller's account.\n   * This can only be executed by the lock owner.\n   */\n  function destroyLock(uint256 lockId) external override {\n    withdraw(lockId, locks[lockId].amount);\n  }\n\n  function withdraw(uint256 lockId, uint256 amount) public override {\n    Lock storage lock = locks[lockId];\n    require(msg.sender == lock.owner, \"!owner\");\n    lock.amount = lock.amount.sub(amount, \"insufficient locked tokens\");\n    (uint256 owed, uint256 dividendShares) = _withdraw(lock, amount);\n    if (lock.amount == 0) {\n      delete locks[lockId];\n      emit LockDestroyed(lockId, msg.sender, owed, dividendShares);\n    } else {\n      emit PartialWithdrawal(lockId, msg.sender, owed, dividendShares);\n    }\n  }\n\n  function _withdraw(Lock memory lock, uint256 amount) internal returns (uint256 owed, uint256 dividendShares) {\n    uint256 earlyWithdrawalFee;\n    (dividendShares, earlyWithdrawalFee) = getWithdrawalParameters(\n      amount,\n      uint256(lock.lockedAt),\n      uint256(lock.lockDuration)\n    );\n    owed = amount.sub(earlyWithdrawalFee);\n\n    IERC20DividendsOwned(dividendsToken).burn(msg.sender, dividendShares);\n    if (earlyWithdrawalFee > 0) {\n      _withdrawFromModule(msg.sender, address(this), amount);\n      depositToken.safeTransfer(msg.sender, owed);\n      pendingFees = safe96(uint256(pendingFees).add(earlyWithdrawalFee));\n      emit FeesReceived(earlyWithdrawalFee);\n    } else {\n      _withdrawFromModule(msg.sender, msg.sender, amount);\n    }\n  }\n\n  function safe96(uint256 n) internal pure returns (uint96) {\n    require(n < 2**96, \"amount exceeds 96 bits\");\n    return uint96(n);\n  }\n\n  /**\n   * @dev Delegate all voting shares the caller has in its sub-delegation module\n   * to `delegatee`.\n   * This will revert if the sub-delegation module does not exist.\n   */\n  function delegate(address delegatee) external override {\n    _delegateFromModule(msg.sender, delegatee);\n  }\n}\n\n\ninterface IERC20DividendsOwned {\n  function mint(address to, uint256 amount) external;\n  function burn(address from, uint256 amount) external;\n  function distribute(uint256 amount) external;\n}"
    },
    "contracts/interfaces/ISharesTimeLock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\nimport \"./IDelegationModule.sol\";\n\n\ninterface ISharesTimeLock is IDelegationModule {\n  event LockCreated(\n    uint256 indexed lockId,\n    address indexed account,\n    uint256 amountLocked,\n    uint256 dividendShares,\n    uint32 duration\n  );\n\n  event LockDestroyed(\n    uint256 indexed lockId,\n    address indexed account,\n    uint256 amount,\n    uint256 dividendShares\n  );\n\n  event PartialWithdrawal(\n    uint256 indexed lockId,\n    address indexed account,\n    uint256 amount,\n    uint256 dividendShares\n  );\n\n  event MinimumDepositSet(uint256 minimumDeposit);\n\n  event FeeRecipientSet(address feeRecipient);\n\n  event FeesReceived(uint256 amount);\n\n  event FeesTransferred(uint256 amount);\n\n  event EmergencyUnlockTriggered();\n\n  /**\n   * @dev Struct for token locks.\n   * @param amount Amount of tokens deposited.\n   * @param lockedAt Timestamp the lock was created at.\n   * @param lockDuration Duration of lock in seconds.\n   * @param owner Account that made the deposit.\n   */\n  struct Lock {\n    uint256 amount;\n    uint32 lockedAt;\n    uint32 lockDuration;\n    address owner;\n  }\n\n  function emergencyUnlockTriggered() external view returns (bool);\n\n  function dividendsToken() external view returns (address);\n\n  function minLockDuration() external view returns (uint32);\n\n  function maxLockDuration() external view returns (uint32);\n\n  function minEarlyWithdrawalFee() external view returns (uint256);\n\n  function baseEarlyWithdrawalFee() external view returns (uint256);\n\n  function maxDividendsBonusMultiplier() external view returns (uint256);\n\n  function locks(uint256) external view returns (uint256 amount, uint32 lockedAt, uint32 lockDuration, address owner);\n  \n  function feeRecipient() external view returns (address);\n\n  function minimumDeposit() external view returns (uint96);\n\n  function pendingFees() external view returns (uint96);\n\n  function getLocksLength() external view returns (uint256);\n\n  function setMinimumDeposit(uint96 minimumDeposit_) external;\n\n  function setFeeRecipient(address feeRecipient_) external;\n\n  function getDividendsMultiplier(uint256 duration) external view returns (uint256 multiplier);\n\n  function getWithdrawalParameters(\n    uint256 amount,\n    uint256 lockedAt,\n    uint256 lockDuration\n  )\n    external\n    view\n    returns (uint256 dividendShares, uint256 earlyWithdrawalFee);\n\n  function triggerEmergencyUnlock() external;\n\n  function distributeFees() external;\n\n  function deposit(uint256 amount, uint32 duration) external returns (uint256);\n\n  function delegate(address delegatee) external;\n\n  function destroyLock(uint256 lockId) external;\n\n  function withdraw(uint256 lockId, uint256 amount) external;\n}"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/test/TestOZERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n\ncontract TestOZERC20 is ERC20 {\n  mapping(address => address) public delegates;\n  event Delegate(address indexed delegator, address indexed delegatee);\n\n  constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {}\n\n  function mint(address account, uint256 amount) external {\n    _mint(account, amount);\n  }\n\n  function delegate(address delegatee) external {\n    delegates[msg.sender] = delegatee;\n    emit Delegate(msg.sender, delegatee);\n  }\n\n  function burn(address account, uint256 amount) public {\n    _burn(account, amount);\n  }\n\n  function transferInternal(address from, address to, uint256 value) public {\n    _transfer(from, to, value);\n  }\n\n  function approveInternal(address owner, address spender, uint256 value) public {\n    _approve(owner, spender, value);\n  }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}